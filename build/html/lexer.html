

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygments.lexer &mdash; pygments-doc 1.1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pygments-doc 1.1.3 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pygments-doc 1.1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pygments.lexer"></span><div class="section" id="pygments-lexer">
<h1>pygments.lexer<a class="headerlink" href="#pygments-lexer" title="Permalink to this headline">¶</a></h1>
<p>Base lexer classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">copyright:</th><td class="field-body">Copyright 2006-2013 by the Pygments team, see AUTHORS.</td>
</tr>
<tr class="field-even field"><th class="field-name">license:</th><td class="field-body">BSD, see LICENSE for details.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pygments.lexer.Lexer">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">Lexer</tt><big>(</big><em>**options</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#Lexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.Lexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Lexer for a specific language.</p>
<p>Basic options recognized:
<tt class="docutils literal"><span class="pre">stripnl</span></tt></p>
<blockquote>
<div>Strip leading and trailing newlines from the input (default: True).</div></blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">stripall</span></tt></dt>
<dd>Strip all leading and trailing whitespace from the input
(default: False).</dd>
<dt><tt class="docutils literal"><span class="pre">ensurenl</span></tt></dt>
<dd>Make sure that the input ends with a newline (default: True).  This
is required for some lexers that consume input linewise.
<em>New in Pygments 1.3.</em></dd>
<dt><tt class="docutils literal"><span class="pre">tabsize</span></tt></dt>
<dd>If given and greater than 0, expand tabs in the input (default: 0).</dd>
<dt><tt class="docutils literal"><span class="pre">encoding</span></tt></dt>
<dd>If given, must be an encoding name. This encoding will be used to
convert the input string to Unicode, if it is not already a Unicode
string (default: <tt class="docutils literal"><span class="pre">'latin1'</span></tt>).
Can also be <tt class="docutils literal"><span class="pre">'guess'</span></tt> to use a simple UTF-8 / Latin1 detection, or
<tt class="docutils literal"><span class="pre">'chardet'</span></tt> to use the chardet library, if it is installed.</dd>
</dl>
<dl class="method">
<dt id="pygments.lexer.Lexer.add_filter">
<tt class="descname">add_filter</tt><big>(</big><em>filter_</em>, <em>**options</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#Lexer.add_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.Lexer.add_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new stream filter to this lexer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.alias_filenames">
<tt class="descname">alias_filenames</tt><em class="property"> = []</em><a class="headerlink" href="#pygments.lexer.Lexer.alias_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Secondary file name globs</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.aliases">
<tt class="descname">aliases</tt><em class="property"> = []</em><a class="headerlink" href="#pygments.lexer.Lexer.aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcuts for the lexer</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pygments.lexer.Lexer.analyse_text">
<em class="property">static </em><tt class="descname">analyse_text</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#Lexer.analyse_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.Lexer.analyse_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Has to return a float between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> that indicates
if a lexer wants to highlight this text. Used by <tt class="docutils literal"><span class="pre">guess_lexer</span></tt>.
If this method returns <tt class="docutils literal"><span class="pre">0</span></tt> it won&#8217;t highlight it in any case, if
it returns <tt class="docutils literal"><span class="pre">1</span></tt> highlighting with this lexer is guaranteed.</p>
<p>The <cite>LexerMeta</cite> metaclass automatically wraps this function so
that it works like a static method (no <tt class="docutils literal"><span class="pre">self</span></tt> or <tt class="docutils literal"><span class="pre">cls</span></tt>
parameter) and the return value is automatically converted to
<cite>float</cite>. If the return value is an object that is boolean <cite>False</cite>
it&#8217;s the same as if the return values was <tt class="docutils literal"><span class="pre">0.0</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.filenames">
<tt class="descname">filenames</tt><em class="property"> = []</em><a class="headerlink" href="#pygments.lexer.Lexer.filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>File name globs</p>
</dd></dl>

<dl class="method">
<dt id="pygments.lexer.Lexer.get_tokens">
<tt class="descname">get_tokens</tt><big>(</big><em>text</em>, <em>unfiltered=False</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#Lexer.get_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.Lexer.get_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of (tokentype, value) pairs generated from
<cite>text</cite>. If <cite>unfiltered</cite> is set to <cite>True</cite>, the filtering mechanism
is bypassed even if filters are defined.</p>
<p>Also preprocess the text, i.e. expand tabs and strip it if
wanted and applies registered filters.</p>
</dd></dl>

<dl class="method">
<dt id="pygments.lexer.Lexer.get_tokens_unprocessed">
<tt class="descname">get_tokens_unprocessed</tt><big>(</big><em>text</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#Lexer.get_tokens_unprocessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.Lexer.get_tokens_unprocessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of (tokentype, value) pairs.
In subclasses, implement this method as a generator to
maximize effectiveness.</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.mimetypes">
<tt class="descname">mimetypes</tt><em class="property"> = []</em><a class="headerlink" href="#pygments.lexer.Lexer.mimetypes" title="Permalink to this definition">¶</a></dt>
<dd><p>MIME types</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.name">
<tt class="descname">name</tt><em class="property"> = None</em><a class="headerlink" href="#pygments.lexer.Lexer.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the lexer</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.Lexer.priority">
<tt class="descname">priority</tt><em class="property"> = 0</em><a class="headerlink" href="#pygments.lexer.Lexer.priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Priority, should multiple lexers match and no content is provided</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pygments.lexer.RegexLexer">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">RegexLexer</tt><big>(</big><em>**options</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#RegexLexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.RegexLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base for simple stateful regular expression-based lexers.
Simplifies the lexing process so that you need only
provide a list of states and regular expressions.</p>
<dl class="attribute">
<dt id="pygments.lexer.RegexLexer.flags">
<tt class="descname">flags</tt><em class="property"> = 8</em><a class="headerlink" href="#pygments.lexer.RegexLexer.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for compiling the regular expressions.
Defaults to MULTILINE.</p>
</dd></dl>

<dl class="method">
<dt id="pygments.lexer.RegexLexer.get_tokens_unprocessed">
<tt class="descname">get_tokens_unprocessed</tt><big>(</big><em>text</em>, <em>stack=('root'</em>, <em>)</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#RegexLexer.get_tokens_unprocessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.RegexLexer.get_tokens_unprocessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Split <tt class="docutils literal"><span class="pre">text</span></tt> into (tokentype, text) pairs.</p>
<p><tt class="docutils literal"><span class="pre">stack</span></tt> is the inital stack (default: <tt class="docutils literal"><span class="pre">['root']</span></tt>)</p>
</dd></dl>

<dl class="attribute">
<dt id="pygments.lexer.RegexLexer.tokens">
<tt class="descname">tokens</tt><em class="property"> = {}</em><a class="headerlink" href="#pygments.lexer.RegexLexer.tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict of <tt class="docutils literal"><span class="pre">{'state':</span> <span class="pre">[(regex,</span> <span class="pre">tokentype,</span> <span class="pre">new_state),</span> <span class="pre">...],</span> <span class="pre">...}</span></tt></p>
<p>The initial state is &#8216;root&#8217;.
<tt class="docutils literal"><span class="pre">new_state</span></tt> can be omitted to signify no state transition.
If it is a string, the state is pushed on the stack and changed.
If it is a tuple of strings, all states are pushed on the stack and
the current state will be the topmost.
It can also be <tt class="docutils literal"><span class="pre">combined('state1',</span> <span class="pre">'state2',</span> <span class="pre">...)</span></tt>
to signify a new, anonymous state combined from the rules of two
or more existing ones.
Furthermore, it can be &#8216;#pop&#8217; to signify going back one step in
the state stack, or &#8216;#push&#8217; to push the current state on the stack
again.</p>
<p>The tuple can also be replaced with <tt class="docutils literal"><span class="pre">include('state')</span></tt>, in which
case the rules from the state named by the string are included in the
current one.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pygments.lexer.ExtendedRegexLexer">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">ExtendedRegexLexer</tt><big>(</big><em>**options</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#ExtendedRegexLexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.ExtendedRegexLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>A RegexLexer that uses a context object to store its state.</p>
<dl class="method">
<dt id="pygments.lexer.ExtendedRegexLexer.get_tokens_unprocessed">
<tt class="descname">get_tokens_unprocessed</tt><big>(</big><em>text=None</em>, <em>context=None</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#ExtendedRegexLexer.get_tokens_unprocessed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.ExtendedRegexLexer.get_tokens_unprocessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Split <tt class="docutils literal"><span class="pre">text</span></tt> into (tokentype, text) pairs.
If <tt class="docutils literal"><span class="pre">context</span></tt> is given, use this lexer context instead.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pygments.lexer.DelegatingLexer">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">DelegatingLexer</tt><big>(</big><em>_root_lexer</em>, <em>_language_lexer</em>, <em>_needle=Token.Other</em>, <em>**options</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#DelegatingLexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.DelegatingLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>This lexer takes two lexer as arguments. A root lexer and
a language lexer. First everything is scanned using the language
lexer, afterwards all <tt class="docutils literal"><span class="pre">Other</span></tt> tokens are lexed using the root
lexer.</p>
<p>The lexers from the <tt class="docutils literal"><span class="pre">template</span></tt> lexer package use this base lexer.</p>
</dd></dl>

<dl class="class">
<dt id="pygments.lexer.LexerContext">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">LexerContext</tt><big>(</big><em>text</em>, <em>pos</em>, <em>stack=None</em>, <em>end=None</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#LexerContext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.LexerContext" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper object that holds lexer position data.</p>
</dd></dl>

<dl class="class">
<dt id="pygments.lexer.include">
<em class="property">class </em><tt class="descclassname">pygments.lexer.</tt><tt class="descname">include</tt><a class="reference internal" href="_modules/pygments/lexer.html#include"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.include" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that a state should include rules from another state.</p>
</dd></dl>

<dl class="function">
<dt id="pygments.lexer.bygroups">
<tt class="descclassname">pygments.lexer.</tt><tt class="descname">bygroups</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#bygroups"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.bygroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback that yields multiple actions for each group in the match.</p>
</dd></dl>

<dl class="function">
<dt id="pygments.lexer.using">
<tt class="descclassname">pygments.lexer.</tt><tt class="descname">using</tt><big>(</big><em>_other</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/pygments/lexer.html#using"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygments.lexer.using" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback that processes the match with a different lexer.</p>
<p>The keyword arguments are forwarded to the lexer, except <cite>state</cite> which
is handled separately.</p>
<p><cite>state</cite> specifies the state that the new lexer will start in, and can
be an enumerable such as (&#8216;root&#8217;, &#8216;inline&#8217;, &#8216;string&#8217;) or a simple
string which is assumed to be on top of the root state.</p>
<p>Note: For that to work, <cite>_other</cite> must not be an <cite>ExtendedRegexLexer</cite>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/lexer.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pygments-doc 1.1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Turbidsoul Chen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>